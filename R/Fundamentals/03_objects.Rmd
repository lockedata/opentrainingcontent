# R objects

So far we've just worked with some single values to get to grips with how some of the various operations work. Of course, we rarely work with a single value! If we did, we could just use a calculator. 

This section helps you get to grips with some different ways of storing data and how to manipulate your datasets in the "traditional" way. This will help you understand a lot of code written in the past, and will equip you to understand the material in the next book, which focuses on data manipulation of tabular data.

## Storing values
When we were performing operations, we got some values output to the console. One of the key principles in writing code is Don't Repeat Yourself (DRY) so we need to know how we can avoid repeating ourselves in R. One of the ways you can do that is to store a value for use later.

In R, we can store values by **assigning** them a name. This makes a **variable** or **object**. We can do this with a few different operators, but the traditional operator is a `<-`^[Other valid values are the equals symbol `=` and you can also do a right-handed assignment with `->`]. The format for assigning a value is `nameofthing <- value`. 

```{r 03_objects-1}
my_variable <- 5 + 3
my_variable > 6 & my_variable < 10
```

```{block 03_objects-2, type="protip"}
By default, when you store values R doesn't return the results to the console. You can change that behaviour by putting brackets around the assignment like `(my_variable <- 5 + 3)`.
```

Valid names for a variable include upper-case letters, lower case letters, numbers anywhere but the beginning, periods (`.`), and hyphens (`_`). 

There are a number of different competing conventions for how you name variables. The most common conventions are shown below. I have no strong feelings for any system and only ask that you pick one and stick with it within a single script.  Whatever you do, don't forget names are case sensitive!

```{r 03_objects-3}
myfirstvariable <- 1
myFirstVariable <- 1
MyFirstVariable <- 1
my_first_variable <- 1
my.first.variable <- 1
```

You can create names breaking the rules governing valid names by placing the rule breaking name between two back-ticks (\`). I don't recommend you do this with variables you'll create, but you'll often end up with names that break conventions when importing data, especially when you import from spreadsheets.

```{r 03_objects-4}
`name with spaces`<- 1
`2017` <- 1
` ` <- 1
`$$$` <- 1
```

Variables you store get stored in-memory. This means they'll hang around whilst R is open and will be gone after that. You can see variables you've created in the Environment tab.

RStudio will by default save your variables for you so that next time you open it up, your variables are stored. 

```{block 03_objects-5, type="protip"}
RStudio saving your variables is a blessing because you don't have to worry about keeping RStudio open the all time. 

It's also a pretty major curse because you'll inevitably create something at some point through the console or an Untitled R file and then lose that bit of code. Now when you're script runs in a fresh session it'll fail. You'll risk tearing your hair out and worse as you go through the pain of debugging this.

I recommend you get in the habit early of not working with your session being saved. Turn it off in *Tools > Global Options*, untick "Restore .RData into workspace at startup" 
```

If you need to manage what's been stored you can list objects with `ls()` and remove them with `rm()`. 

```{r 03_objects-6}
today<-Sys.Date()
rm("today")
```

Another way you can remove a single object is to overwrite the object with value NULL. 
```{r 03_objects-7}
today<-Sys.Date()
today<-NULL
```

If you want to remove everything you can use`ls()` inside `rm()` but you have to tell the function you're providing a list of variable names.

```{r 03_objects-8, eval=FALSE}
ls()
rm(list=ls())
```

You can also achieve the same results by using the broom symbol in the Environment tab in RStudio.

## Vectors
A **vector** is a collection of values that hold the same datatype. It is **one-dimensional** in that none of the **elements** in the collection correspond to other values like they might in a table of values.

A single value is actually a vector of **length** 1.

When I introduced the colon (`:`) as a means of generating a sequence, we were in fact generating a vector where each element was a number in the sequence. The vector has a length which is as long as the number of values generated by the sequence.

```{r 03_objects-9}
-1:1
```

Another way of producing a vector is to use the combine function (`c()`). This is great for combining a number of disparate character strings into a vector. 
```{r 03_objects-10}
c("red","yellow","blue")
```

A single value is a still a vector. What we see when we use the `c()` function is that we're combining vectors. As a result we can also use it on longer vectors too.

```{r 03_objects-11}
c(1:3, 2:1, 5:8)
```

When we combine values into a single vector, R will change everything to the same datatype using some conversions.

```{r 03_objects-12}
c(1, FALSE)
c(1, "FALSE")
```

```{block 03_objects-13, type='glass'}
This **implicit conversion** is something to be careful of and can really screw up your results! If in doubt, check the datatype with the `class()` function, or look for the vector in your global environment and see what the datatype is from there.
```

We can also give names to values being included in a vector.

```{r 03_objects-14}
c(first="Steph", last="Locke")
```

## Getting information about vectors
Our `class()` function will still work with a vector with a length greater than 1 to get you it's datatype. 

Let's look at a sequence of numbers and one of the built-in vectors that contains the alphabet.

```{r 03_objects-15, linewidth=60}
class(1:10)
LETTERS
class(LETTERS)
```

We can use the `length()` function to find out the number of elements in a vector.

```{r 03_objects-16}
length(pi)
length(LETTERS)
```

To extract the names of values in a vector, we can use the `names()` function.

```{r 03_objects-17}
steph<-c(Steph="forename", Locke="surname")
names(steph)
```

## Calculations on multiple vectors
When we perform calculations on two vectors, R will try to perform the operation for each set of elements. This is an **element-wise** or **pair-wise** calculation methodology. 

In SQL, it's equivalent to where you might write `colA*colB` and you'll get the answer calculated for every row in the table. In Excel, it's equivalent to a Fill Down of multiplying two values on the same row. 

Let's looks at how this works in practice in R. 

We have two vectors, each containing two elements.

```{r 03_objects-18}
vecA <- 1:2
vecB <- 2:3
```

```{r 03_objects-19, echo=FALSE}
1:2
2:3
```
If we want to multiply the two vectors by each other, R will match each element in the first vector with it's counterpart in the second and multiply the two values together to make a new element.

```{r 03_objects-20}
vecA*vecB 
```

![](img/vectormult.png)

We can also do this with vectors of different lengths to a certain extent. The most common scenario is operating on a vector by doing something with a single value.

A single value is a vector of length 1. When R gets a request to do something with a vector of length *X* and a vector of length 1, it will basically repeat the vector of length 1 *X* times to make two vectors the same length. It will then perform the calculation element-wise.

```{r 03_objects-21}
vecA*3 
```

![](img/vectormultsingle.png)

You can also use this functionality of making a vector the same length as another, known as **recycling**, work for other mis-matched vector sizes. The only rule is that one of the vector lengths must divide cleanly by the other. 

- Two vectors of the same length divide by the other's length exactly one time and won't need to recycle
- A vector of length one always cleanly divides any other vector's length and so will be recycled
- A vector of length 2, will divide any vector with an even length and so will be recycled in those cases, but it cannot recycle cleanly for odd length vectors

```{r 03_objects-22, eval=FALSE, linewidth=60}
1:10 * 2
1:10 * 2:3
1:10 * 2:4
```
```{r 03_objects-23, echo=FALSE, linewidth=60}
1:10 * 2
1:10 * 2:3
print("longer object length is not a multiple of shorter object length")
```

![](img/vectormultrecycle.png)

Vector recycling is useful and dangerous -- it can help you make elegant code or give you unexpected results. Especially when starting out, I recommend you make your vectors either the same length or length 1.


### Bitwise
Our logical operators that we covered earlier, work in a pairwise fashion. They'll return a vector of the same length as the longest one used in your logical statement.

```{r 03_objects-24}
a<-1:2>1
b<-2:3>1
```

```{r 03_objects-25, echo = FALSE}
1:2>1
2:3>1
```

Making logical statements returns vectors with a logical datatype.

```{r 03_objects-26}
a&b
a|b
```

Occasionally, you expect to only be operating on a single pair of values and want to enforce that R should only do the calculation on the first pair. In R, this called a **bitwise** AND (`&&`) or OR (`||`). 

A bitwise logical statement will only do the check for the first elements in the vectors and ignore all the others. 


```{r 03_objects-27}
a&&b
a||b
```

Use bitwise operators with extreme care!

## data.frames
A **data.frame** is a table similar to what we're used to working with in most data analysis tools. It will contain a number of rows with columns containing different pieces of information. Each column in a data.frame has a datatype but it does not have to be the same datatype as the other columns.

We can construct a data.frame from individual vectors via the `data.frame()` function.

```{r 03_objects-28}
data.frame(a=1:2,b=c("blue","red"))
```

You can also give row names to the rows you end up making, however, I recommend you add these in as a column instead as it'll make them easier to work with long-term.

```{r 03_objects-29, tidy=FALSE}
baddf <- data.frame(a = 1:2,
                   b = c("blue","red"),
                   row.names = c("First","Second"))

gooddf <- data.frame(a = 1:2,
                   b = c("blue","red"),
                   ID = c("First","Second"))
```

Throughout many of the examples, I'll use the example datasets that are available by default in R.

```{r 03_objects-30, eval=FALSE}
View(iris)
```

```{r 03_objects-31, echo=FALSE}
knitr::kable(head(iris))
```


```{block 03_objects-32, type="protip"}
The `View()` function is specific to RStudio and provides a nice visual grid view of a data.frame and it allows you to search and sort the table for some initial exploration.
```

More commonly, we'll import data from an outside source.

## Importing data.frames
You can import data via code, but one of the easiest ways of getting started is to load data via RStudio and have it generate the code for you.

To import data... 

1. Go to the Environment tab and select Import Dataset
2. Select the relevant type of data you want to import
3. Browse to the file you want to upload.

```{block 03_objects-33, type="protip"}
Keeping data in the project directory is ideal as it keeps everything in one place and makes imported code easier to read.
```

You can tweak the advanced settings and then select the *Import* button to load the data directly into memory. Alternatively, you can copy the code it generated for you and paste it into a script. By doing this copy and pasting, you will make the import reproducible. Next time you need to load the data you can just run the code, instead of using the interface again.

### Error!! 
![](img/readrerror.png)

If you were tying to do this import you may have gotten an error when you tried to load a file because you don't have some of the required functionality that RStudio expects you to have.

It will tell you the name of the thing you're missing. In my case - I'm missing the package "readr". To make this available to us, we go to the Packages tab and then:

1. select *Install*
2. type "readr"
3. select the *Install* button
4. accept any popups for things like restarting R

## Getting information about data.frames
Our data.frames are **composites**, they are the result of combining a number of vectors with different data types. As a consequence, when we run our `class()` function, it tells us an object is a `data.frame` and no longer returns the underlying datatype.

```{r 03_objects-34}
class(iris)
```

You do not get the number of rows in a data.frame when you run the `length()` function, instead you get the number of columns^[This is because a data.frame is actually just a prettily printed list, and each column in an element in said list, and length returns the number of elements overall.]. Alternatively, you can run the more clearly named `ncol()` function to return the number of columns in a data.frame.

```{r 03_objects-35}
length(iris)
ncol(iris)
```

You can get the number of rows via the `nrow()` function.

```{r 03_objects-36}
nrow(iris)
```

Similarly to `length()`, the `names()` function when applied to data.frame's only works on the columns, so you can use it to get column names. A clearer alternative is to use the `colnames()` function. You can use `rownames()` to get names for rows, if they exist.

```{r 03_objects-37, tidy=FALSE}
mydf <- data.frame(a = 1:2, 
                   b = c("blue","red"), 
                   row.names = c("First","Second"))

names(mydf)
colnames(mydf)
rownames(mydf)
```


## Lists
**List**s are a catch-all object. They literally hold any and all types of the objects covered in this section, including list objects!

You can create lists with the `list()` function, and like with our other objects you can have named and unnamed elements.

In this example, we create a list object holding two vectors. 

```{r 03_objects-38, linewidth=60}
mylist<-list(a=1:3, LETTERS)
mylist
```

At least initially, most people tend to work with their data in a data.frame and may only interact with a list as a consequence of doing something like building a linear regression model. Lists are very common outputs to statistical functions because you need things like a formula, fitted results, coefficients, model metrics, and more. If you do build a model though, there's a bunch of helper functions for extracting different components so you don't even have to think about the fact you're working with a list.

### Getting information about lists
The `length()` function will tell you how many elements there are in a list.

```{r 03_objects-39}
length(mylist)
```

`names()` lets you get the element names and returns a blank (`""`) where no name was provided.
```{r 03_objects-40}
names(mylist)
```

## Other object types
There a number of other object types in R. They won't be covered in detail in this book, because they tend to be used by a small fraction of R users.

- A **matrix** is a two-dimensional object that can only contain one datatype
- An **array** is a multi-dimensional object that also can contain only one datatype
- A **table** object is similar to a matrix but is created by producing a contingency table

In R, developers can also create other object types specific to their requirements. People use this to create geospatial objects and more. I don't recommend you think about creating your own custom objects, especially at this point in your R writing career. If/when you want to write your own custom classes then my preferred package for that is `R6`.


## Useful functions
Whatever the object type, there are some functions that come in handy for exploring it and getting some useful metadata.

You get the contents of any object by writing it's name.

```{r 03_objects-41, linewidth=60}
mylist
```

However, if you're working with a lot of data, you probably don't want to fill up your console that way. R has two functions, `head()` and `tail()`, which allow you to see values from the beginning or end of an object. For objects containing many elements, such as lists or data.tables, `head()` and `tail()` returns the first or last 5 values respectively.
```{r 03_objects-42}
head(LETTERS)
tail(LETTERS)
```

If you want to examine an R object, you can use the `str()` function to get the structure of the object.
```{r 03_objects-43}
str(mylist)
```

## Summary
You can perform calculations on the fly or store results for later use. You can assign values with the `<-` operator.

Functions like `class()`, `length()`, and `head()` work well to extract information about R objects.

R performs calculations over vectors so that you only have to provide two or more vector names and the operation you want performed. R will then perform this operation pair-wise for the vectors.

You can import datasets in R by using the "Import Dataset" function. This will also give you the code to use so that you can write code that another person will be able to use. This is great because it makes your work reproducible and automatable!

As well as vectors and data.frames, there are list object types and some other object types. These are less commonly used, although lists are quite common when getting outputs from statistical functions.

## R objects exercises
1. See what's in the built-in variable `letters`
2. Write a check to see if "A" is present in `letters`
3. Find out which values in the sequence 1 to 10 are greater than or equal to 3 and less than 7
4. Make a vector containing the numbers 1 to 50
5. Make a vector containing two words
6. What happens when you combine these two vectors?
7. Make a data.frame using the two vectors
8. What happened to your text vector?
9. Make a list containing some of the variables you've created so far
10. Retrieve the head or tail of the `iris` dataset
